<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>kevin's blog</title><link>https://iamdurant.github.io</link><description>生存还是毁灭，这是一个值得考虑的问题</description><copyright>kevin's blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://assets.leetcode.cn/aliyun-lc-upload/users/tender-satoshino0/avatar_1692271843.png</url><title>avatar</title><link>https://iamdurant.github.io</link></image><lastBuildDate>Fri, 21 Jun 2024 07:50:28 +0000</lastBuildDate><managingEditor>kevin's blog</managingEditor><ttl>60</ttl><webMaster>kevin's blog</webMaster><item><title>初识B树</title><link>https://iamdurant.github.io/post/chu-shi-B-shu.html</link><description>### B树的degree(阶数)&#13;
&#13;
&gt; - 几阶B树即代表最多能有多少个孩子，除叶子节点以外，节点的孩子不少于`阶数/2`&#13;
&gt; - 那么除叶子节点以外，节点key的数量范围为`阶数/2 - 1 到 阶数 - 1`&#13;
&#13;
### B树的节点实现，静态内部类，简化设计，不考虑Object，只有key&#13;
&#13;
```java&#13;
static class Node {&#13;
        int[] keys;             // key for compare&#13;
        Node[] children;        // children pointer&#13;
        int keyNum;             // key size&#13;
        boolean leaf = true;    // leaf or not&#13;
        int t;                  // minDegree&#13;
&#13;
        public Node(int minDegree){&#13;
            this.t = minDegree;&#13;
            keys = new int[2 * t - 1];&#13;
            children = new Node[2 * t];&#13;
        }&#13;
&#13;
        public Node find(int key){&#13;
            int i;&#13;
            for (i = 0;i &lt; keyNum;i++){&#13;
                if (keys[i] == key)&#13;
                    return this;&#13;
                if (keys[i] &gt; key)&#13;
                    break;&#13;
            }&#13;
&#13;
            if (leaf)&#13;
                return null;&#13;
&#13;
            return children[i].find(key);&#13;
        }&#13;
&#13;
        public void insertKey(int index, int key){&#13;
            System.arraycopy(keys, index, keys, index + 1, keyNum - index);&#13;
            keys[index] = key;&#13;
            keyNum++;&#13;
        }&#13;
&#13;
        public void insertNode(int index, Node node){&#13;
            System.arraycopy(children, index, children, index + 1, keyNum - index);&#13;
            children[index] = node;&#13;
        }&#13;
&#13;
        @Override&#13;
        public String toString() {&#13;
            StringBuilder sb = new StringBuilder();&#13;
            sb.append('[');&#13;
            for (int i = 0;i &lt; keyNum;i++){&#13;
                sb.append(keys[i]);&#13;
                if (i != keyNum - 1)&#13;
                    sb.append(',');&#13;
            }&#13;
            sb.append(']');&#13;
&#13;
            return sb.toString();&#13;
        }&#13;
    }&#13;
```&#13;
&#13;
### key的插入&#13;
&#13;
1. 将根节点作为此节点，若找到相同的key，则更新&#13;
2. 若此节点不存在此key，则判断是否为叶子节点，若是，则插入，否则此节点更新为chiildren[i]&#13;
3. 若插入完成后`满key`了，则**分裂此节点**&#13;
&#13;
#### 什么是满key&#13;
&#13;
&gt; 若degree(度)为4，即最多4个孩子&#13;
则t = 2，那么key满的个数为3，若插入新key，达到3个即为满key状态，要进行分裂&#13;
&#13;
#### 节点分裂&#13;
&#13;
1. 创建新的节点，将大&gt;=t索引的key与children移动到此新节点，**特殊情况：**`若分裂节点为根节点，则除了构建一个right节点以外，还需构建一个新根节点`&#13;
2. 将索引为t的key移动到父亲节点`若父亲的索引i为此节点`，**特殊情况**：`若分裂节点不是叶子节点 则还需将分裂节点的children复制到right节点`&#13;
3. 将新创建的节点作为父亲的 i+1索引节点&#13;
4. 最后，记得更新分裂节点的keyNumber&#13;
&#13;
&gt; 从宏观上看节点的分裂过程，就是将索引为t-1的key移动到父节点 将索引为t之后(**包括t**)的key移动给新构建的right节点&#13;
&#13;
#### B树完整的插入代码&#13;
&#13;
```java&#13;
public void put(int key){&#13;
        doPut(null, 0, root, key);&#13;
    }&#13;
&#13;
    private void doPut(Node parent, int index, Node node, int key){&#13;
        int i = 0;&#13;
        while (i &lt; node.keyNum){&#13;
            if (key == node.keys[i])&#13;
                return;&#13;
            if (key &lt; node.keys[i])&#13;
                break;&#13;
            i++;&#13;
        }&#13;
&#13;
        if (node.leaf){&#13;
            // 插入&#13;
            node.insertKey(i, key);&#13;
        } else {&#13;
            // 递归插入&#13;
            doPut(node, i, node.children[i], key);&#13;
        }&#13;
&#13;
        if (node.keyNum == MAX_KEY_NUM){&#13;
            // 节点分裂&#13;
            split(node, parent, index);&#13;
        }&#13;
    }&#13;
&#13;
    private void split(Node node, Node parent, int index){&#13;
        if (parent == null){&#13;
            Node newRoot = new Node(t);&#13;
            newRoot.insertNode(0, node);&#13;
            newRoot.leaf = false;&#13;
            parent = newRoot;&#13;
            root = newRoot;&#13;
        }&#13;
&#13;
        Node right = new Node(t);&#13;
        right.leaf = node.leaf;&#13;
        System.arraycopy(node.keys, t, right.keys, 0, t - 1);&#13;
        if (!node.leaf){&#13;
            System.arraycopy(node.children, t, right.children, 0, t);&#13;
        }&#13;
&#13;
        right.keyNum = t - 1;&#13;
&#13;
        parent.insertKey(index, node.keys[t - 1]);&#13;
        parent.insertNode(index + 1, right);&#13;
        node.keyNum = t - 1;&#13;
    }&#13;
```&#13;
#### B树插入代码测试&#13;
```java&#13;
    /**&#13;
     * degree: 4&#13;
     * t: 2&#13;
     *           5            2|5&#13;
     *         /   \   ==&gt;   / | \&#13;
     *      1|2|3   6       1  3  6&#13;
     *               分裂过程&#13;
     */&#13;
    public static void main(String[] args) {&#13;
        BTree bTree = new BTree(2);&#13;
        bTree.put(1);&#13;
        bTree.put(2);&#13;
        bTree.put(5);&#13;
        bTree.put(6);&#13;
        bTree.put(3);&#13;
&#13;
        System.out.println();&#13;
    }&#13;
```&#13;
&#13;
---&#13;
&#13;
### key的删除&#13;
&#13;
相对来说，删除key比插入key复杂的多，开始之间，先在Node节点类添加9个辅助方法（直接调用），让删除key的逻辑更加清晰：&#13;
&#13;
&gt;- `删除指定index的key并返回`&#13;
&#13;
```java&#13;
public int removeKey(int index){&#13;
    int re = keys[index];&#13;
    System.arraycopy(keys, index + 1, keys, index, keyNum - index - 1);&#13;
    return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `移除最左边的key并返回`&#13;
&#13;
```java&#13;
public int removeKey(int index){&#13;
    int re = keys[index];&#13;
    System.arraycopy(keys, index + 1, keys, index, keyNum - index - 1);&#13;
    return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `移除最右边的key并返回`&#13;
&#13;
```java&#13;
public int removeRightestKey(){&#13;
    int re = keys[keyNum - 1];&#13;
    return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `移除指定index的child并返回`&#13;
&#13;
```java&#13;
public Node removeChild(int index){&#13;
    Node re = children[index];&#13;
    System.arraycopy(children, index + 1, children, index, keyNum - index - 1);&#13;
    return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `移除最左边child并返回`&#13;
&#13;
```java&#13;
public Node removeLeftestChild(){&#13;
     Node re = children[0];&#13;
     System.arraycopy(children, 1, children, 0, keyNum - 1);&#13;
     return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `移除最右边的child并返回`&#13;
&#13;
```java&#13;
public Node removeRightestChild(){&#13;
     Node re = children[keyNum - 1];&#13;
     return re;&#13;
}&#13;
```&#13;
&#13;
&gt;- `获取指定index的左兄弟`&#13;
&#13;
```java&#13;
public Node leftBrother(int index){&#13;
    return index &gt; 0 ? children[index - 1] : null;&#13;
}&#13;
```&#13;
&#13;
&gt;- `获取指定index的右兄弟`&#13;
&#13;
```java&#13;
public Node rightBrother(int index){&#13;
    return index == keyNum ? null : children[index + 1];&#13;
}&#13;
```&#13;
&#13;
&gt;- `将节点的所有key与child移动到指定节点`&#13;
&#13;
```java&#13;
public void removeNode(Node target){&#13;
    int start = target.keyNum;&#13;
    if (keyNum &gt;= 0) System.arraycopy(keys, 0, target.keys, start, keyNum);&#13;
    if (!leaf){&#13;
        if (keyNum &gt;= 0) System.arraycopy(children, 0, target.children, start, keyNum);&#13;
    }&#13;
}&#13;
```&#13;
&#13;
#### 删除key的各种case&#13;
&#13;
- 若节点为叶子节点&#13;
  - 存在指定key，直接返回&#13;
  - 不存在指定key，删除操作&#13;
- 若节点为非叶子节点&#13;
  - 不存在指定key，递归删除&#13;
  - 存在指定key，找到后继key，与后继key交换，删除后继key（相当于限定了删除操作只能在叶子节点进行）&#13;
- 删除上述操作完成后，归向上判断是否需要合并（key数 &lt; t - 1）&#13;
&#13;
#### 合并操作&#13;
&#13;
- 根节点&#13;
  - 哈哈&#13;
  - 哈哈&#13;
- 非根节点&#13;
  - 哈哈&#13;
  - 哈哈&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://iamdurant.github.io/post/chu-shi-B-shu.html</guid><pubDate>Thu, 20 Jun 2024 13:04:19 +0000</pubDate></item><item><title>重识yaml</title><link>https://iamdurant.github.io/post/zhong-shi-yaml.html</link><description>### spring将yaml格式作为配置文件格式，必须得好好熟悉一下&#13;
&#13;
### 基本语法&#13;
&#13;
- 大小写敏感&#13;
- 使用缩进表示层级关系&#13;
- 缩进值允许使用空格，不允许使用tab&#13;
- 缩进的空格数不重要，只要保证相同层级的左对齐即可&#13;
- 使用`#`表示注释&#13;
&#13;
### yaml对象&#13;
&#13;
以键值对的方式表示 中间用`: `分隔key &amp; value，`:`号后面带**一个**空格&#13;
&#13;
```yaml&#13;
key: &#13;
  value1&#13;
  value2&#13;
```&#13;
&#13;
### yaml数组&#13;
&#13;
yaml数组用`- `号开头，`:`号后面带**一个**空格&#13;
&#13;
```yaml&#13;
arr: &#13;
 - a&#13;
 - b&#13;
 - c&#13;
```&#13;
&#13;
也可以表示多维数组，需控制层级&#13;
&#13;
```yaml&#13;
array: &#13;
  -&#13;
    - a&#13;
    - b&#13;
    - c&#13;
  -&#13;
    - x&#13;
    - y&#13;
    - z&#13;
```&#13;
&#13;
对象数组，就像java中的`Person p1 = new Person('薛大炮', 18);Person p2 = new Person('蔡徐坤', 26);Person[] persons = new Person[]{p1, p2};`&#13;
&#13;
```yaml&#13;
persons&#13;
  -&#13;
    name: 薛大炮&#13;
    age: 18&#13;
  -&#13;
    name: 蔡徐坤&#13;
    age: 26&#13;
```&#13;
&#13;
### 复合结构&#13;
&#13;
对象和数组可以构成复杂的结构关系&#13;
&#13;
```yaml&#13;
languages: &#13;
  - Java&#13;
  - C++&#13;
  - Go&#13;
WebSites: &#13;
  baidu: https://www.baidu.com&#13;
  google: https:www.google.com&#13;
  bing: https:www.bing.com&#13;
```&#13;
&#13;
对应到json为&#13;
&#13;
```json&#13;
{&#13;
  'languages': ['Java', 'C++', 'Go'],&#13;
  'WebSites': {&#13;
    'baidu': 'https://www.baidu.com',&#13;
    'google': 'https:www.google.com',&#13;
    'bing': 'https:www.bing.com'&#13;
  }&#13;
}&#13;
```&#13;
&#13;
### 纯量&#13;
&#13;
纯量是最基本的，不可再分的值&#13;
- 字符串&#13;
- 整数&#13;
- 浮点数&#13;
- 布尔值&#13;
- null&#13;
- 时间（date）&#13;
- 日期（datetime）&#13;
&#13;
以一个例子来看各纯量的使用&#13;
&#13;
```yaml&#13;
string: &#13;
  - 哈哈            # 字符串可直接写&#13;
  - 'good'         # 或者单引号引表示&#13;
  - '西海岸'        # 或者双引号表示&#13;
  - you jump       # 字符串可写多行，每行被转化为空格即为` you jump i jump！`&#13;
    i jump！&#13;
&#13;
int: &#13;
  - 123&#13;
  - 0100_1101     # 二进制表示&#13;
 &#13;
float: &#13;
  - 66.6&#13;
  - 45.1231402+e5      # 可以使用科学计数法表示&#13;
&#13;
boolean: &#13;
  - TRUE&#13;
  - FALSE&#13;
  - True&#13;
  - False&#13;
  - true&#13;
  - false        # 其实 true false 全小写最常用&#13;
&#13;
null: &#13;
  - a&#13;
  - ~            # 使用~表示null&#13;
&#13;
date: 2024-06-20       # 使用ISO-8601标准：yyyy-MM-dd&#13;
&#13;
datetime: 2024-06-20T16:34:20+09:00     # 使用ISO-8601标准：yyyy-MM-ddTHH:mm:ss+时区&#13;
```&#13;
&#13;
### 引用&#13;
&#13;
`&amp;`表示锚点，`*`表示引用锚点，`&lt;&lt;: `表示合并到当前数据流&#13;
&#13;
```yaml&#13;
database: &amp;database&#13;
  host: 127.0.0.1&#13;
  port: 3306&#13;
  user: root&#13;
  password: 123456&#13;
&#13;
mysql: &#13;
  &lt;&lt;: *database             # 若未生效 则mardown解析器不兼容&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://iamdurant.github.io/post/zhong-shi-yaml.html</guid><pubDate>Thu, 20 Jun 2024 08:45:56 +0000</pubDate></item><item><title>初窥markdown</title><link>https://iamdurant.github.io/post/chu-kui-markdown.html</link><description>### 首先呢，要学会markdown语法，markdown语法非常强大，实在是太酷了，迫不及待要看一看它的语法了！！&#13;
&#13;
### 标题&#13;
&#13;
就标题来说只需在文字前面加上（# ），是的，一个#号加一个空格，后面再跟上标题即可，#号越多 标题越小&#13;
&#13;
### 引用&#13;
&#13;
&gt; 只需在文本开头前加上`&gt; `即可（后面带空格）&#13;
&#13;
### 粗体、斜体、粗体斜体&#13;
&#13;
这是斜体 *哈哈哈哈*  文本块前后各加一个星号&#13;
这是加粗 **呵呵呵呵** 文本块前后各加两个星号&#13;
这是斜体与加粗 ***嘻嘻嘻嘻*** 文本块前后各加三个星号&#13;
&#13;
### 无序列表&#13;
&#13;
无序列表的使用也是相当清晰，就像yaml的数组一样，当然了，控制层级的话只需在前面控制空格数量就好了&#13;
- 苹果&#13;
- 香蕉&#13;
- 蔬菜&#13;
  - 青菜&#13;
  - 白菜&#13;
&#13;
### 有序列表&#13;
&#13;
有序列表只需在数字或者符号后加上`. `即可（后面有空格）,&#13;
1. 科比&#13;
2. 杜兰特&#13;
3. 乔丹&#13;
&#13;
### 链接&#13;
&#13;
链接的格式：`[]()` 方括号里面是文字 圆括号里面是连接地址&#13;
比如：[来吧，now，is movie time！！！](https://nunflix.com)&#13;
&#13;
### 图片&#13;
&#13;
哇哇哇哦，图片就比较刺激了，格式：`![]()`，基于连接，由感叹号开头，方括号里面是文字(在这里是图片描述) 圆括号里面是连接地址&#13;
比如：&#13;
![我的leetcode头像](https://assets.leetcode.cn/aliyun-lc-upload/users/tender-satoshino0/avatar_1692271843.png)&#13;
&#13;
### 分割线&#13;
&#13;
格式：`---` 就是三个减号 三个减号上面还需空一行&#13;
&#13;
---&#13;
&#13;
### 表格&#13;
&#13;
表格就更有意思了，太new了，太潮流了&#13;
&#13;
格式：`|`用来分割，第二行的`:` 用来代表左对齐还是右对齐，或者中间对齐&#13;
&#13;
![表格格式](https://github.com/iamdurant/iamdurant.github.io/assets/107034526/5410dc3a-1e97-426e-b8b5-a629ca4f25d6)&#13;
&#13;
&#13;
| 学号 | 姓名 | 年龄 |&#13;
|     :----------     |    :---     |     :--    |&#13;
|     2020132238     |      蔡徐坤   |      23   |&#13;
|     2020132221     |     薛大炮    |    24     |&#13;
|     2020132249    |     洲饱饱    |      23   |&#13;
&#13;
**上述有我的idol 以及我的两个brother，能被我写进blog，是我的brother的福气**&#13;
&#13;
### 脚注&#13;
&#13;
脚注就比较叼了格式也是基于链接：`[](脚注解释 '脚注名字')`&#13;
&#13;
- [全栈工程师](全栈工程师就是。</description><guid isPermaLink="true">https://iamdurant.github.io/post/chu-kui-markdown.html</guid><pubDate>Wed, 19 Jun 2024 17:43:00 +0000</pubDate></item></channel></rss>