### 基于比较的排序算法，常见有：

![各排序算法复杂度](https://github.com/iamdurant/iamdurant.github.io/assets/107034526/e9360d33-8b17-45d3-affe-1d0a7527914c)

#### 1. 冒泡排序

**思想**

重复遍历数组（每次遍历不断减少），每轮遍历不断比较并往后交换较大值，用一个变量记录最近的一次交换，可以减少交换次数， 
在部分有序的情况下，可以减少交换次数。

```java
public static void bubbleSort(int[] nums) {
        int j = nums.length - 1;
        while (true) {
            int x = 0;
            for (int i = 0;i < j;i++) {
                if (nums[i] > nums[i + 1]) {
                    int tmp = nums[i];
                    nums[i] = nums[i + 1];
                    nums[i + 1] = tmp;
                    x = i;
                }
            }
            if (j == 0)
                break;
            j = x;
        }
    }
```

#### 2. 选择排序

**思想**

将数组分为两部分，从后往前每轮遍历获取最大值并进行交换，减少了交换次数。

```java
public static void selectionSort(int[] nums) {
        int maxIdx;
        int r = nums.length - 1;
        do {
            maxIdx = r;
            for (int i = 0; i < r; i++) {
                maxIdx = nums[i] > nums[maxIdx] ? i : maxIdx;
            }

            if (nums[r] != nums[maxIdx] && maxIdx != r){
                int tmp = nums[r - 1];
                nums[r - 1] = nums[maxIdx];
                nums[maxIdx] = tmp;
            }

            r--;
        } while (r != 0);
    }
```

#### 3. 堆排序
#### 4. 插入排序

**思想**

将数组分为两部分，左边为有序部分，右边为无序部分，每次从无序部分挑选最左值往有序部分插入（方向为从large到small）

```java
public static void insertionSort(int[] nums) {
        int left = 1;
        int i;
        while (left != nums.length) {
            int tmp = nums[left];

            i = left - 1;
            for (;i >= 0;i--) {
                if (tmp < nums[i]) {
                    nums[i + 1] = nums[i];
                } else {
                    nums[i + 1] = tmp;
                    break;
                }
            }

            if (i < 0)
                nums[0] = tmp;
            left++;
        }
    }
```

#### 5. 希尔排序

**思想**

基于插入排序，用gap进行分组排序，可以减少移动次数。

```java
public static void shellSort(int[] nums) {
        for (int g = nums.length >> 1;g >= 1;g = g >> 1) {
            for (int x = 0;x + g < nums.length;x++) {
                int left = x + g;
                int i;
                while (left < nums.length) {
                    int tmp = nums[left];

                    i = left - g;
                    for (;i >= 0;i-=g) {
                        if (tmp < nums[i]) {
                            nums[i + g] = nums[i];
                        } else {
                            nums[i + g] = tmp;
                            break;
                        }
                    }

                    if (i < 0)
                        nums[x] = tmp;
                    left+=g;
                }
            }
        }
    }
```

#### 6. 归并排序

**思想**

可以分解为子问题，不断划分数组，当数组大小为1时返回（有序），返回的过程中合并两个有序部分。

```java
public static void mergeSort(int[] nums) {
        helpMS(nums, 0, nums.length - 1);
    }

    private static void helpMS(int[] nums, int l, int r) {
        if (l == r)
            return;

        int m = (l + r) >> 1;
        helpMS(nums, l, m);
        helpMS(nums, m + 1, r);

        int[] temp = new int[r - l + 1];
        int x = l;
        int y = m + 1;
        int idx = 0;
        while (x <= m && y <= r) {
            if (nums[x] < nums[y]){
                temp[idx++] = nums[x];
                x++;
            } else {
                temp[idx++] = nums[y];
                y++;
            }
        }

        if (x <= m) {
            for (int i = x;i <= m;i++){
                temp[idx++] = nums[i];
            }
        } else {
            for (int i = y;i <= r;i++){
                temp[idx++] = nums[i];
            }
        }

        System.arraycopy(temp, 0, nums, l, temp.length);
    }
```

**归并排序（迭代法实现）**

```java
    // 迭代归并排序
    public static void mergeSortIterative(int[] arr) {
        int n = arr.length;

        // 当前大小的子数组
        for (int currSize = 1; currSize < n; currSize *= 2) {
            // 当前子数组的左起始点
            for (int leftStart = 0; leftStart < n - 1; leftStart += 2 * currSize) {
                // 找到子数组的中点和右结束点
                int mid = Math.min(leftStart + currSize - 1, n - 1);
                int rightEnd = Math.min(leftStart + 2 * currSize - 1, n - 1);

                // 合并子数组
                merge(arr, leftStart, mid, rightEnd);
            }
        }
    }
    
    // 合并两个子数组 arr[l..m] 和 arr[m+1..r]
    public static void merge(int[] arr, int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;

        // 创建临时数组
        int[] L = new int[n1];
        int[] R = new int[n2];

        // 拷贝数据到临时数组
        System.arraycopy(arr, l, L, 0, n1);
        System.arraycopy(arr, m + 1, R, 0, n2);

        // 合并临时数组

        // 初始索引
        int i = 0, j = 0;

        // 初始合并子数组的索引
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // 拷贝L[]的剩余元素
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // 拷贝R[]的剩余元素
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
```

#### 7. 快速排序




